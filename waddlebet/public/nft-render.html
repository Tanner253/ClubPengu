<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>NFT Renderer</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { 
            background: transparent; 
            overflow: hidden;
            width: 512px;
            height: 512px;
        }
        #canvas-container {
            width: 512px;
            height: 512px;
            position: relative;
        }
        canvas { 
            display: block;
            width: 512px;
            height: 512px;
        }
        /* Gradient background for NFT card look */
        .gradient-bg {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: -1;
        }
        /* Rarity-based gradients */
        .rarity-common { background: linear-gradient(135deg, #1a1a2e 0%, #16213e 50%, #1a1a2e 100%); }
        .rarity-uncommon { background: linear-gradient(135deg, #0d2818 0%, #1a4d2e 50%, #0d2818 100%); }
        .rarity-rare { background: linear-gradient(135deg, #0d1b2a 0%, #1b3a5f 50%, #0d1b2a 100%); }
        .rarity-epic { background: linear-gradient(135deg, #1a0a2e 0%, #3d1a5c 50%, #1a0a2e 100%); }
        .rarity-legendary { background: linear-gradient(135deg, #2a0a1a 0%, #5c1a3d 50%, #2a0a1a 100%); }
        .rarity-mythic { background: linear-gradient(135deg, #2a0a0a 0%, #5c1a1a 50%, #2a0a0a 100%); }
        .rarity-divine { background: linear-gradient(135deg, #2a1a0a 0%, #5c3d1a 50%, #2a1a0a 100%); }
        /* Quality glow effects */
        .quality-pristine::after {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 300px;
            height: 300px;
            background: radial-gradient(circle, rgba(255,255,255,0.1) 0%, transparent 70%);
            pointer-events: none;
        }
        .quality-flawless::after {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 350px;
            height: 350px;
            background: radial-gradient(circle, rgba(255,215,0,0.15) 0%, transparent 70%);
            pointer-events: none;
        }
        .holographic::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(45deg, 
                rgba(255,0,0,0.05) 0%, 
                rgba(255,127,0,0.05) 14%, 
                rgba(255,255,0,0.05) 28%, 
                rgba(0,255,0,0.05) 42%, 
                rgba(0,0,255,0.05) 57%, 
                rgba(75,0,130,0.05) 71%, 
                rgba(148,0,211,0.05) 85%,
                rgba(255,0,0,0.05) 100%
            );
            pointer-events: none;
        }
        /* Item info overlay */
        .item-info {
            position: absolute;
            bottom: 20px;
            left: 20px;
            right: 20px;
            color: white;
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, sans-serif;
            text-shadow: 0 2px 4px rgba(0,0,0,0.8);
        }
        .item-name {
            font-size: 24px;
            font-weight: 700;
            margin-bottom: 4px;
        }
        .item-serial {
            font-size: 14px;
            opacity: 0.8;
        }
        .item-badges {
            display: flex;
            gap: 8px;
            margin-top: 8px;
        }
        .badge {
            padding: 4px 8px;
            border-radius: 4px;
            font-size: 11px;
            font-weight: 600;
            text-transform: uppercase;
        }
        .badge-first-edition { background: linear-gradient(135deg, #FFD700, #FFA500); color: #000; }
        .badge-holographic { background: linear-gradient(135deg, #00ffff, #ff00ff); color: #000; }
        .badge-quality-pristine { background: rgba(255,255,255,0.2); border: 1px solid rgba(255,255,255,0.4); }
        .badge-quality-flawless { background: linear-gradient(135deg, #FFD700, #FF6B6B); color: #000; }
        /* Rarity label */
        .rarity-label {
            position: absolute;
            top: 20px;
            right: 20px;
            padding: 6px 12px;
            border-radius: 4px;
            font-family: 'Inter', sans-serif;
            font-size: 12px;
            font-weight: 700;
            text-transform: uppercase;
            letter-spacing: 1px;
        }
        .rarity-label-common { background: #6B7280; color: white; }
        .rarity-label-uncommon { background: #22C55E; color: white; }
        .rarity-label-rare { background: #3B82F6; color: white; }
        .rarity-label-epic { background: #A855F7; color: white; }
        .rarity-label-legendary { background: linear-gradient(135deg, #EC4899, #F472B6); color: white; }
        .rarity-label-mythic { background: linear-gradient(135deg, #EF4444, #F87171); color: white; }
        .rarity-label-divine { background: linear-gradient(135deg, #F59E0B, #FBBF24); color: #000; }
        /* Collection branding */
        .collection-brand {
            position: absolute;
            top: 20px;
            left: 20px;
            font-family: 'Inter', sans-serif;
            font-size: 14px;
            font-weight: 600;
            color: rgba(255,255,255,0.6);
        }
    </style>
</head>
<body>
    <div id="canvas-container">
        <div id="gradient-bg" class="gradient-bg rarity-common"></div>
        <div class="collection-brand">WaddleBet</div>
        <div id="rarity-label" class="rarity-label rarity-label-common">Common</div>
        <div class="item-info">
            <div id="item-name" class="item-name">Loading...</div>
            <div id="item-serial" class="item-serial">#0001</div>
            <div id="item-badges" class="item-badges"></div>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        // Voxel size for rendering
        const VOXEL_SIZE = 0.5;
        
        // Parse URL parameters
        const params = new URLSearchParams(window.location.search);
        const cosmetic = {
            templateId: params.get('templateId') || 'topHat',
            category: params.get('category') || 'hat',
            name: params.get('name') || 'Top Hat',
            rarity: params.get('rarity') || 'common',
            quality: params.get('quality') || 'standard',
            serialNumber: parseInt(params.get('serialNumber')) || 1,
            isHolographic: params.get('holographic') === 'true',
            isFirstEdition: params.get('firstEdition') === 'true',
            assetKey: params.get('assetKey') || params.get('templateId') || 'topHat',
            skin: params.get('skin') || 'blue'
        };

        // Update UI elements
        document.getElementById('item-name').textContent = cosmetic.name;
        document.getElementById('item-serial').textContent = `#${String(cosmetic.serialNumber).padStart(4, '0')}`;
        
        // Set rarity styling
        const gradientBg = document.getElementById('gradient-bg');
        const rarityLabel = document.getElementById('rarity-label');
        gradientBg.className = `gradient-bg rarity-${cosmetic.rarity}`;
        rarityLabel.className = `rarity-label rarity-label-${cosmetic.rarity}`;
        rarityLabel.textContent = cosmetic.rarity.charAt(0).toUpperCase() + cosmetic.rarity.slice(1);
        
        // Add quality effects
        if (cosmetic.quality === 'pristine') {
            gradientBg.classList.add('quality-pristine');
        } else if (cosmetic.quality === 'flawless') {
            gradientBg.classList.add('quality-flawless');
        }
        
        // Holographic effect
        if (cosmetic.isHolographic) {
            gradientBg.classList.add('holographic');
        }
        
        // Add badges
        const badgesContainer = document.getElementById('item-badges');
        if (cosmetic.isFirstEdition) {
            const badge = document.createElement('div');
            badge.className = 'badge badge-first-edition';
            badge.textContent = '1st Edition';
            badgesContainer.appendChild(badge);
        }
        if (cosmetic.isHolographic) {
            const badge = document.createElement('div');
            badge.className = 'badge badge-holographic';
            badge.textContent = 'Holographic';
            badgesContainer.appendChild(badge);
        }
        if (cosmetic.quality === 'pristine') {
            const badge = document.createElement('div');
            badge.className = 'badge badge-quality-pristine';
            badge.textContent = 'Pristine';
            badgesContainer.appendChild(badge);
        } else if (cosmetic.quality === 'flawless') {
            const badge = document.createElement('div');
            badge.className = 'badge badge-quality-flawless';
            badge.textContent = 'Flawless';
            badgesContainer.appendChild(badge);
        }

        // ===== THREE.JS PENGUIN RENDERER =====
        
        const container = document.getElementById('canvas-container');
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(45, 1, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer({ 
            antialias: true, 
            alpha: true,
            preserveDrawingBuffer: true 
        });
        
        renderer.setSize(512, 512);
        renderer.setPixelRatio(2); // Higher quality
        renderer.setClearColor(0x000000, 0);
        container.insertBefore(renderer.domElement, container.firstChild);

        // Lighting
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
        scene.add(ambientLight);
        
        const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
        directionalLight.position.set(5, 10, 7);
        scene.add(directionalLight);
        
        const fillLight = new THREE.DirectionalLight(0xffffff, 0.3);
        fillLight.position.set(-5, 5, -5);
        scene.add(fillLight);

        // Skin colors
        const SKIN_COLORS = {
            blue: '#1E90FF',
            red: '#DC143C',
            green: '#32CD32',
            yellow: '#FFD700',
            purple: '#9370DB',
            pink: '#FF69B4',
            orange: '#FF8C00',
            black: '#2F2F2F',
            white: '#F5F5F5',
            teal: '#20B2AA',
            lime: '#7CFC00',
            gold: '#FFD700',
            silver: '#C0C0C0'
        };

        // Get penguin body color
        const bodyColor = SKIN_COLORS[cosmetic.skin] || SKIN_COLORS.blue;

        // Generate penguin body voxels
        function generatePenguinBody() {
            const voxels = [];
            const white = '#FFFFFF';
            const black = '#1a1a1a';
            
            // Head (sphere-ish)
            for (let x = -4; x <= 4; x++) {
                for (let y = 5; y <= 10; y++) {
                    for (let z = -4; z <= 4; z++) {
                        const d = x*x + (y-7.5)*(y-7.5) + z*z;
                        if (d <= 18) {
                            const isFront = z > 1;
                            voxels.push({ x, y, z, c: isFront ? white : bodyColor });
                        }
                    }
                }
            }
            
            // Eyes
            voxels.push({ x: -2, y: 8, z: 4, c: black });
            voxels.push({ x: 2, y: 8, z: 4, c: black });
            
            // Beak
            voxels.push({ x: 0, y: 7, z: 4, c: '#FFA500' });
            voxels.push({ x: 0, y: 7, z: 5, c: '#FFA500' });
            voxels.push({ x: -1, y: 7, z: 4, c: '#FFA500' });
            voxels.push({ x: 1, y: 7, z: 4, c: '#FFA500' });
            
            // Body (oval)
            for (let x = -5; x <= 5; x++) {
                for (let y = -4; y <= 5; y++) {
                    for (let z = -4; z <= 4; z++) {
                        const d = (x*x)/25 + (y*y)/81 + (z*z)/16;
                        if (d <= 1) {
                            const isFront = z > 1;
                            voxels.push({ x, y, z, c: isFront ? white : bodyColor });
                        }
                    }
                }
            }
            
            // Flippers
            for (let y = 0; y <= 4; y++) {
                voxels.push({ x: -6, y, z: 0, c: bodyColor });
                voxels.push({ x: 6, y, z: 0, c: bodyColor });
            }
            
            // Feet
            for (let x = -3; x <= -1; x++) {
                for (let z = 0; z <= 2; z++) {
                    voxels.push({ x, y: -5, z, c: '#FFA500' });
                }
            }
            for (let x = 1; x <= 3; x++) {
                for (let z = 0; z <= 2; z++) {
                    voxels.push({ x, y: -5, z, c: '#FFA500' });
                }
            }
            
            return voxels;
        }

        // Cosmetic assets (simplified versions)
        const COSMETIC_ASSETS = {
            // Hats
            topHat: (() => {
                let v = [];
                for(let x=-5; x<=5; x++) for(let z=-5; z<=5; z++) if(x*x+z*z < 25) v.push({x, y:10, z, c: '#222'});
                for(let y=10; y<16; y++) for(let x=-3; x<=3; x++) for(let z=-3; z<=3; z++) if(x*x+z*z < 9) v.push({x, y, z, c: '#222'});
                for(let x=-3; x<=3; x++) for(let z=-3; z<=3; z++) if(x*x+z*z < 9.5 && x*x+z*z > 8) v.push({x, y:11, z, c: '#D00'});
                return v;
            })(),
            crown: (() => {
                let v = [];
                for(let x=-4; x<=4; x++) for(let z=-4; z<=4; z++) if(x*x+z*z > 12 && x*x+z*z < 18) {
                    v.push({x, y:10, z, c: 'gold'});
                    v.push({x, y:11, z, c: 'gold'});
                    if((x+z)%3===0) v.push({x, y:12, z, c: 'gold'});
                }
                return v;
            })(),
            flamingCrown: (() => {
                let v = [];
                for(let x=-4; x<=4; x++) for(let z=-4; z<=4; z++) if(x*x+z*z > 10 && x*x+z*z < 18) {
                    v.push({x, y:10, z, c: '#FFD700'});
                    v.push({x, y:11, z, c: '#FFD700'});
                    if((x+z)%2===0) v.push({x, y:12, z, c: '#FFD700'});
                }
                v.push({x:0, y:12, z:0, c: '#FF4500', glow: true});
                v.push({x:3, y:12, z:0, c: '#FF4500', glow: true});
                v.push({x:-3, y:12, z:0, c: '#FF4500', glow: true});
                v.push({x:0, y:13, z:0, c: '#FF6347', glow: true});
                v.push({x:0, y:14, z:0, c: '#FF8C00', glow: true});
                return v;
            })(),
            halo: (() => {
                let v = [];
                for(let x=-4; x<=4; x++) for(let z=-4; z<=4; z++) if(x*x+z*z > 12 && x*x+z*z < 18) v.push({x, y:14, z, c: 'gold', glow:true});
                return v;
            })(),
            santa: (() => {
                const v = [];
                for(let x=-5; x<=5; x++) for(let z=-5; z<=5; z++) {
                    const d = x*x + z*z;
                    if(d < 26 && d > 12) v.push({x, y:10, z, c:'white'});
                }
                for(let x=-4; x<=4; x++) for(let z=-4; z<=4; z++) if(x*x+z*z < 17) v.push({x, y:11, z, c:'red'});
                for(let x=-3; x<=3; x++) for(let z=-3; z<=3; z++) if(x*x+z*z < 10) v.push({x, y:12, z, c:'red'});
                for(let x=-2; x<=2; x++) for(let z=-2; z<=2; z++) if(x*x+z*z < 5) v.push({x, y:13, z, c:'red'});
                v.push({x:0, y:14, z:0, c:'red'});
                v.push({x:0, y:15, z:0, c:'white'});
                return v;
            })(),
            wizardHat: (() => {
                let v = [];
                for(let x=-6; x<=6; x++) for(let z=-6; z<=6; z++) if(x*x+z*z < 40) v.push({x, y:9, z, c:'#4B0082'});
                for(let y=10; y<17; y++) {
                    const r = Math.max(1, 5 - (y-10)*0.6);
                    for(let x=-r; x<=r; x++) for(let z=-r; z<=r; z++) if(x*x+z*z < r*r) v.push({x, y, z, c:'#4B0082'});
                }
                v.push({x:2, y:12, z:3, c:'gold', glow: true});
                v.push({x:-1, y:14, z:2, c:'gold', glow: true});
                v.push({x:0, y:17, z:0, c:'#FF69B4', glow: true});
                return v;
            })(),
            cowboy: (() => {
                let v = [];
                for(let x=-6; x<=6; x++) for(let z=-6; z<=6; z++) if(x*x+z*z < 40) v.push({x, y:10, z, c: 'brown'});
                for(let x=-3; x<=3; x++) for(let z=-3; z<=3; z++) if(x*x+z*z < 12) for(let y=11; y<14; y++) v.push({x, y, z, c: 'brown'});
                return v;
            })(),
            // Body items
            bowtie: (() => {
                let v = [];
                v.push({x:-2, y:4, z:4, c:'red'});
                v.push({x:-1, y:4, z:4, c:'red'});
                v.push({x:0, y:4, z:4, c:'#8B0000'});
                v.push({x:1, y:4, z:4, c:'red'});
                v.push({x:2, y:4, z:4, c:'red'});
                return v;
            })(),
            cape: (() => {
                let v = [];
                for(let y=-3; y<=4; y++) {
                    for(let x=-4; x<=4; x++) {
                        v.push({x, y, z:-4, c:'red'});
                    }
                }
                return v;
            })(),
            angelWings: (() => {
                let v = [];
                for(let y=0; y<=5; y++) {
                    const spread = Math.floor((5 - Math.abs(y-2.5)) * 1.5);
                    for(let x=5; x<=5+spread; x++) {
                        v.push({x, y, z:-2, c:'white', glow: true});
                    }
                    for(let x=-5; x>=-5-spread; x--) {
                        v.push({x, y, z:-2, c:'white', glow: true});
                    }
                }
                return v;
            })(),
            // Mounts
            skateboard: (() => {
                let v = [];
                for(let x=-4; x<=4; x++) {
                    v.push({x, y:-6, z:0, c:'#8B4513'});
                    v.push({x, y:-6, z:1, c:'#8B4513'});
                }
                v.push({x:-3, y:-7, z:0.5, c:'#333'});
                v.push({x:3, y:-7, z:0.5, c:'#333'});
                return v;
            })()
        };

        // Create voxel mesh from voxel data
        function createVoxelMesh(voxels) {
            const group = new THREE.Group();
            const geometry = new THREE.BoxGeometry(VOXEL_SIZE, VOXEL_SIZE, VOXEL_SIZE);
            
            // Group voxels by color for instancing
            const colorGroups = {};
            voxels.forEach(v => {
                const key = v.c + (v.glow ? '_glow' : '');
                if (!colorGroups[key]) {
                    colorGroups[key] = { color: v.c, glow: v.glow, positions: [] };
                }
                colorGroups[key].positions.push(v);
            });
            
            // Create instanced meshes for each color
            Object.values(colorGroups).forEach(colorGroup => {
                const material = new THREE.MeshStandardMaterial({
                    color: colorGroup.color,
                    emissive: colorGroup.glow ? colorGroup.color : '#000000',
                    emissiveIntensity: colorGroup.glow ? 0.5 : 0,
                    metalness: 0.1,
                    roughness: 0.8
                });
                
                const instancedMesh = new THREE.InstancedMesh(
                    geometry,
                    material,
                    colorGroup.positions.length
                );
                
                const matrix = new THREE.Matrix4();
                colorGroup.positions.forEach((v, i) => {
                    matrix.setPosition(v.x * VOXEL_SIZE, v.y * VOXEL_SIZE, v.z * VOXEL_SIZE);
                    instancedMesh.setMatrixAt(i, matrix);
                });
                
                instancedMesh.instanceMatrix.needsUpdate = true;
                group.add(instancedMesh);
            });
            
            return group;
        }

        // Build the penguin with cosmetic
        function buildPenguin() {
            const penguinGroup = new THREE.Group();
            
            // Base penguin body
            const bodyVoxels = generatePenguinBody();
            const bodyMesh = createVoxelMesh(bodyVoxels);
            penguinGroup.add(bodyMesh);
            
            // Add cosmetic based on category
            const assetKey = cosmetic.assetKey;
            const cosmeticVoxels = COSMETIC_ASSETS[assetKey];
            
            if (cosmeticVoxels) {
                const cosmeticMesh = createVoxelMesh(cosmeticVoxels);
                penguinGroup.add(cosmeticMesh);
            }
            
            return penguinGroup;
        }

        // Create and position penguin
        const penguin = buildPenguin();
        penguin.position.set(0, 0, 0);
        penguin.rotation.y = Math.PI * 0.15; // Slight angle for better view
        scene.add(penguin);

        // Position camera
        camera.position.set(0, 2, 18);
        camera.lookAt(0, 1, 0);

        // Render
        function render() {
            renderer.render(scene, camera);
        }
        
        render();
        
        // Notify parent that rendering is complete
        window.renderComplete = true;
        if (window.onRenderComplete) {
            window.onRenderComplete();
        }
        
        // Also dispatch custom event
        window.dispatchEvent(new CustomEvent('renderComplete'));
    </script>
</body>
</html>

